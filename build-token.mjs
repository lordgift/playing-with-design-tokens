// import { createRequire } from 'node:module';
// const require = createRequire(import.meta.url);

// const StyleDictionary = require('style-dictionary');
// const fs = require('fs-extra');

import StyleDictionary from 'style-dictionary';
import fs from 'fs-extra';

import designTokenJson from '/Users/gift/Documents/scgprojects/design-tokens-sync/tokens.json' assert { type: "json" };;

// 📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝
function tokensToMultifiles() {
    let keys = Object.keys(designTokenJson);
    keys.forEach( tokenGroup => {
        let file = `tokens-multi-files/${tokenGroup}.json`;
        fs.ensureFileSync(file);
        fs.writeJsonSync(file, designTokenJson[tokenGroup], {spaces: 4});
    });
}

process.argv.slice(2).forEach(arg => {
    if (arg == "-e") {
        tokensToMultifiles();
    } 
})
// 📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝


// Generate Android dimens for sizes in dp unit. (for avoid unknown 16 multiplication ??)
StyleDictionary.registerFormat({
    name: 'android/Colors+',
    format: ({ dictionary }) => {

        // console.debug(dictionary);

        var contents = "";
        dictionary.allTokens
            .filter(token => token.type === 'color')
            .forEach(token => {

                let tokenValue = token.value
                if (tokenValue.startsWith("#")) {
                    contents += `<color name="${token.name}">${tokenValue}</color>\n    `;
                }
                // tokenValue is rgba e.g.rgba(255, 255, 255, 0.08)
                else if (tokenValue.startsWith("rgba")) {
                    contents += `<color name="${token.name}">#${rgba2hex(tokenValue)}</color>\n    `;
                }
            });


        return `<?xml version="1.0" encoding="UTF-8"?>
<!--
  Customized based-on StyleDictionary

  Do not edit directly
  Generated by LordGift on ${Date()}
-->
<resources>
    ${contents}
</resources>
        `;

    }
});



// Generate Android dimens for sizes in dp unit. (for avoid unknown 16 multiplication ??)
StyleDictionary.registerFormat({
    name: 'android/Dimens+',
    format: ({ dictionary }) => {


        var contents = "";
        dictionary.allTokens
            .filter(token => token.type === 'sizing' || token.type === 'borderRadius' || token.type === 'spacing')
            .forEach(token => {
                var tokenValue = token.value.replaceAll(/px/g, "");
                contents += `<dimens name="${token.name}">${tokenValue}dp</dimens>\n    `;
            });


        return `<?xml version="1.0" encoding="UTF-8"?>
<!--
  Customized based-on StyleDictionary

  Do not edit directly
  Generated by LordGift on ${Date()}
-->
<resources>
    ${contents}
</resources>
        `;

    }
});


// Generate Android dimens for sizes in dp unit. (for avoid unknown 16 multiplication ??)
StyleDictionary.registerFormat({
    name: 'android/FontDimens+',
    format: ({ dictionary }) => {


        var contents = "";
        dictionary.allTokens
            .filter(token => token.type === 'fontSizes' )
            .forEach(token => {
                var tokenValue = token.value.replaceAll(/px/g, "");
                contents += `<dimens name="${token.name}">${tokenValue}sp</dimens>\n    `;
            });


        return `<?xml version="1.0" encoding="UTF-8"?>
<!--
  Customized based-on StyleDictionary

  Do not edit directly
  Generated by LordGift on ${Date()}
-->
<resources>
    ${contents}
</resources>
        `;

    }
});


// Generate iOS Enum colors with xcassets.
StyleDictionary.registerFormat({
    name: 'ios-swift/Colors+',
    format: ({ dictionary }) => {

        var classContents = "";

        //Generate xcassets
        const assetsDir = 'build/ios-swift/StyleDictionaryColorSet.xcassets';
        dictionary.allTokens
            .filter(token => token.type === 'color')
            .forEach(token => {

                // console.log(token);

                const folder = `${assetsDir}/${token.name}.colorset`;
                const file = `${folder}/Contents.json`;
                const contents = {
                    colors: [
                        {
                            "color" : {
                                'color-space': "srgb",
                                components: extractToComponents(token)
                            },
                            idiom: "universal"
                        }
                    ]
                };
                // create the directory if it doesn't exist
                fs.ensureDirSync(folder);
                // create the Contents.json file
                fs.writeFileSync(file, JSON.stringify(contents, null, 2));

                console.warn(`\x1b[1;33m✔︎ ${file}`);

                classContents += `static var ${token.name}: Color { Color("${token.name}")}\n\t`
            });
        return `//
//  Customized based-on StyleDictionary
//
//  Do not edit directly
//  Generated by LordGift on ${Date()}
//
import SwiftUI

extension ShapeStyle where Self == Color {
    ${classContents}
}`;

    }
});


// Generate iOS dimens for sizes. (for avoid unknown 16 multiplication ??)
StyleDictionary.registerFormat
StyleDictionary.registerFormat({
    name: 'ios-swift/Sizes+',
    format: ({ dictionary }) => {


        var classContents = "";
        dictionary.allTokens
            .filter(token => token.type === 'sizing' || token.type === 'borderRadius' || token.type === 'spacing')
            .forEach(token => {
                var tokenValue = token.value.replaceAll(/px/g, "");
                classContents += `static var ${token.name}: Double = ${tokenValue} \n\t`
            });


        return `//
//  Customized based-on StyleDictionary
//
//  Do not edit directly
//  Generated by LordGift on ${Date()}
//
import SwiftUI

extension Double {
    ${classContents}
}`;

    }
});

// Generate iOS dimens for sizes. (for avoid unknown 16 multiplication ??)
StyleDictionary.registerFormat({
    name: 'ios-swift/FontSizes+',
    format: ({ dictionary }) => {


        var classContents = "";
        dictionary.allTokens
            .filter(token => token.type === 'fontSizes' )
            .forEach(token => {
                var tokenValue = token.value.replaceAll(/px/g, "");
                classContents += `static var ${token.name}: Double = ${tokenValue} \n\t`
            });


        return `//
//  Customized based-on StyleDictionary
//
//  Do not edit directly
//  Generated by LordGift on ${Date()}
//
import SwiftUI

extension Double {
    ${classContents}
}`;

    }
});


/* 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 */
const sd = new StyleDictionary('./config.json');
await sd.hasInitialized;

const sdExtended = await sd.extend({
    source: ["tokens-multi-files/**/*.json"]
});

await sdExtended.cleanAllPlatforms();
await sdExtended.buildAllPlatforms();
/* 🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥 */


function extractToComponents(token) {
    let tokenName = token.name;
    let tokenValue = token.value;

    try {
        var jsonComponents = "";

        // tokenValue is hex e.g.#112233
        if (tokenValue.startsWith("#")) {
            var crappyJSON = `{ "alpha" : "1.000", "red" : "0x${tokenValue.substring(1,3)}", "green" : "0x${tokenValue.substring(3,5)}", "blue" : "0x${tokenValue.substring(5,7)}" }`; 
            jsonComponents = JSON.parse(crappyJSON); 
/* 
  "components": {
    "alpha": "1.000",
    "red": "0xff",
    "green": "0xff",
    "blue": "0xff"
   }
*/
        }

        // tokenValue is UIColor e.g.UIColor(red: 0.823, green: 0.890, blue: 0.210, alpha: 1)
        else if (tokenValue.startsWith("UIColor")) {
            var cleaupSwift = tokenValue.replace(/UIColor\(/, "{").replace(/\)/, "}")
            var appendedQuot = cleaupSwift.replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": '); 
            jsonComponents = JSON.parse(appendedQuot); 
/* 
  "components": {
    "red": 0.823,
    "green": 0.890,
    "blue": 0.210,
    "alpha": 1
   }
*/
        } 

        // tokenValue is rgba e.g.rgba(41, 51, 43, 0.12)
        else if (tokenValue.match(/rgba\((\d+),\W?(\d+),\W?(\d+),\W?(\d+.\d+)\)/g)) {
            var jsonRGBA = tokenValue.replace(/rgba\((\d+),\W?(\d+),\W?(\d+),\W?(\d+.\d+)\)/g, `{"red": "$1", "blue": "$2", "green": "$3", "alpha": "$4"}`); 
            jsonComponents = JSON.parse(jsonRGBA); 
/* 
  "components": {
    "red": "41",
    "green": "51",
    "blue": "43",
    "alpha": "0.12"
   }
*/
        } 

        else {
            console.error(`Mismatch pattern for token ${tokenName} = ${tokenValue}`);
        }
        
        return jsonComponents;
    } catch (e) {
        console.error(e);
        return ""
    }
    
}

//rgba(0, 0, 0, 0.74) => 000000bc
function rgba2hex(orig) {
    var a, isPercent,
        rgb = orig.replace(/\s/g, '').match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i),
        alpha = (rgb && rgb[4] || "").trim(),
        hex = rgb ?
        (rgb[1] | 1 << 8).toString(16).slice(1) +
        (rgb[2] | 1 << 8).toString(16).slice(1) +
        (rgb[3] | 1 << 8).toString(16).slice(1) : orig;

    if (alpha !== "") {
        a = alpha;
    } else {
        a = "01";
    }
    // multiply before convert to HEX
    a = ((a * 255) | 1 << 8).toString(16).slice(1)
    hex = hex + a;

    return hex;
}